#include "./constructor_call.hpp"
#include "../../IR/control_flow.hpp"
#include "../../IR/types/maybe.hpp"
#include "../../IR/types/region.hpp"
#include "../constants/unsigned_literal.hpp"
#include "llvm/IR/Constants.h"

namespace qat::ast {

ConstructorCall::ConstructorCall(QatType* _type, Vec<Expression*> _exps, Maybe<OwnType> _ownTy,
                                 Maybe<QatType*> _ownerType, Maybe<Expression*> _ownCount, FileRange _fileRange)
    : Expression(std::move(_fileRange)), type(_type), args(std::move(_exps)), ownTy(_ownTy), ownerType(_ownerType),
      ownCount(_ownCount) {}

IR::PointerOwner ConstructorCall::getIRPtrOwnerTy(IR::Context* ctx) const {
  switch (ownTy.value_or(OwnType::parent)) {
    case OwnType::type: {
      if (!ctx->getActiveFunction()->isMemberFunction()) {
        ctx->Error("The current function is not a member function of any type", fileRange);
      }
      return IR::PointerOwner::OfType(((IR::MemberFunction*)ctx->getActiveFunction())->getParentType());
    }
    case OwnType::heap:
      return IR::PointerOwner::OfHeap();
    case OwnType::parent:
      return IR::PointerOwner::OfParentFunction(ctx->getActiveFunction());
    case OwnType::region: {
      if (!ownerType) {
        ctx->Error("No region provided and hence the pointer cannot have " + ctx->highlightError("region") + " owner",
                   fileRange);
      }
      auto* regionTy = ownerType.value()->emit(ctx);
      if (!regionTy->isRegion()) {
        ctx->Error("The provided owner is not a region type and hence the pointer cannot have " +
                       ctx->highlightError("region") + " owner",
                   fileRange);
      }
      return IR::PointerOwner::OfRegion(regionTy->asRegion());
    }
  }
}

String ConstructorCall::ownTyToString() const {
  switch (ownTy.value()) {
    case OwnType::type:
      return "type";
    case OwnType::heap:
      return "heap";
    case OwnType::parent:
      return "parent";
    case OwnType::region:
      return "region";
  }
}

IR::Value* ConstructorCall::emit(IR::Context* ctx) {
  SHOW("Constructor Call - Emitting type")
  auto* typ = type->emit(ctx);
  SHOW("Emitted type")
  if (ownCount.has_value()) {
    SHOW("Own count is present")
    // NOLINTBEGIN(readability-magic-numbers)
    if (ownCount.value()->hasTypeInferrance()) {
      ownCount.value()->asTypeInferrable()->setInferenceType(IR::UnsignedType::get(64u, ctx));
    }
    SHOW("Own count type inference complete")
    // NOLINTEND(readability-magic-numbers)
  }
  auto* oCount      = ownCount.has_value() ? ownCount.value()->emit(ctx) : nullptr;
  bool  hasOwnCount = false;
  auto  ownerValue  = getIRPtrOwnerTy(ctx);
  if (oCount) {
    SHOW("Has own count")
    hasOwnCount   = true;
    auto* countTy = oCount->isReference() ? oCount->getType()->asReference()->getSubType() : oCount->getType();
    if (!countTy->isUnsignedInteger()) {
      ctx->Error("Invalid type for number of instances to allocate", ownCount.value()->fileRange);
    }
    if (oCount->isReference()) {
      oCount->loadImplicitPointer(ctx->builder);
    }
    if (oCount->isReference() || oCount->isImplicitPointer()) {
      oCount = new IR::Value(ctx->builder.CreateLoad(countTy->getLLVMType(), oCount->getLLVM()), countTy, false,
                             IR::Nature::temporary);
    }
    SHOW("Loaded reference/implicit pointer")
  } else {
    if (ownCount.has_value()) {
      ctx->Error("Value generated by the count is null", ownCount.value()->fileRange);
    }
  }
  if (typ->isExpanded()) {
    auto*             eTy = typ->asExpanded();
    Vec<IR::Value*>   valsIR;
    Vec<IR::QatType*> valsType;
    for (auto* arg : args) {
      auto* argVal = arg->emit(ctx);
      valsType.push_back(argVal->getType());
      valsIR.push_back(argVal);
    }
    SHOW("Argument values emitted for function call")
    IR::MemberFunction* cons = nullptr;
    if (args.empty()) {
      if (eTy->hasDefaultConstructor()) {
        cons = eTy->getDefaultConstructor();
        if (!cons->isAccessible(ctx->getAccessInfo())) {
          ctx->Error("The default constructor of type " + ctx->highlightError(eTy->getFullName()) +
                         " is not accessible here",
                     fileRange);
        }
        SHOW("Found default constructor")
      } else {
        ctx->Error(
            "Type " + ctx->highlightError(eTy->toString()) +
                " does not have a default constructor and hence arguments have to be provided in this constructor call",
            fileRange);
      }
    } else if (args.size() == 1) {
      if (eTy->hasFromConvertor(valsType.front())) {
        cons = eTy->getFromConvertor(valsType.front());
        if (!cons->isAccessible(ctx->getAccessInfo())) {
          ctx->Error("This convertor of type " + ctx->highlightError(eTy->getFullName()) + " is not accessible here",
                     fileRange);
        }
        SHOW("Found convertor with type")
      } else {
        ctx->Error("No from convertor found for type " + ctx->highlightError(eTy->getFullName()) + " with type " +
                       ctx->highlightError(valsType.front()->toString()),
                   fileRange);
      }
    } else {
      if (eTy->hasConstructorWithTypes(valsType)) {
        cons = eTy->getConstructorWithTypes(valsType);
        if (!cons->isAccessible(ctx->getAccessInfo())) {
          ctx->Error("This constructor of type " + ctx->highlightError(eTy->getFullName()) + " is not accessible here",
                     fileRange);
        }
        SHOW("Found constructor with types")
      } else {
        ctx->Error("No matching constructor found for type " + ctx->highlightError(eTy->getFullName()), fileRange);
      }
    }
    SHOW("Found convertor/constructor")
    // NOLINTNEXTLINE(clang-analyzer-core.CallAndMessage)
    auto argTys = cons->getType()->asFunction()->getArgumentTypes();
    for (usize i = 1; i < argTys.size(); i++) {
      if (argTys.at(i)->getType()->isReference()) {
        if (!valsType.at(i - 1)->isReference()) {
          if (!valsIR.at(i - 1)->isImplicitPointer()) {
            valsIR.at(i - 1)->makeImplicitPointer(ctx, None);
          }
          if (argTys.at(i)->getType()->asReference()->isSubtypeVariable() && !valsIR.at(i - 1)->isVariable()) {
            ctx->Error("The expected argument type is " + ctx->highlightError(argTys.at(i)->getType()->toString()) +
                           " but the provided value is not a variable",
                       args.at(i - 1)->fileRange);
          }
        } else {
          if (argTys.at(i)->getType()->asReference()->isSubtypeVariable() &&
              !valsIR.at(i - 1)->getType()->asReference()->isSubtypeVariable()) {
            ctx->Error("The expected argument type is " + ctx->highlightError(argTys.at(i)->getType()->toString()) +
                           " but the provided value is of type " +
                           ctx->highlightError(valsIR.at(i - 1)->getType()->toString()),
                       args.at(i - 1)->fileRange);
          }
        }
      } else {
        auto* valTy = valsType.at(i - 1);
        auto* val   = valsIR.at(i - 1);
        if (valTy->isReference() || val->isImplicitPointer()) {
          if (valTy->isReference()) {
            valTy = valTy->asReference()->getSubType();
          }
          valsIR.at(i - 1) = new IR::Value(ctx->builder.CreateLoad(valTy->getLLVMType(), val->getLLVM()), valTy, false,
                                           IR::Nature::temporary);
        }
      }
    }
    SHOW("About to create llAlloca")
    llvm::Value* llAlloca;
    if (ownTy.has_value()) {
      ctx->getMod()->linkNative(IR::NativeUnit::malloc);
      auto* mallocFn = ctx->getMod()->getLLVMModule()->getFunction("malloc");
      if (hasOwnCount) {
        if (ownTy.value() != OwnType::region) {
          llAlloca = ctx->builder.CreatePointerCast(
              ctx->builder.CreateCall(
                  mallocFn->getFunctionType(), mallocFn,
                  {ctx->builder.CreateMul(
                      llvm::ConstantInt::get(
                          llvm::Type::getInt64Ty(ctx->llctx),
                          ctx->getMod()->getLLVMModule()->getDataLayout().getTypeAllocSize(eTy->getLLVMType())),
                      oCount->getLLVM())}),
              eTy->getLLVMType()->getPointerTo());
        } else {
          llAlloca = ownerValue.ownerAsRegion()->ownData(eTy, oCount->getLLVM(), ctx)->getLLVM();
        }
      } else {
        if (ownTy.value() != OwnType::region) {
          llAlloca = ctx->builder.CreatePointerCast(
              ctx->builder.CreateCall(mallocFn->getFunctionType(), mallocFn,
                                      {llvm::ConstantExpr::getSizeOf(eTy->getLLVMType())}),
              eTy->getLLVMType()->getPointerTo());
        } else {
          llAlloca = ownerValue.ownerAsRegion()->ownData(eTy, None, ctx)->getLLVM();
        }
      }
    } else {
      if (isLocalDecl()) {
        if (localValue->getType()->isMaybe()) {
          llAlloca = ctx->builder.CreateStructGEP(localValue->getType()->getLLVMType(), localValue->getAlloca(), 1u);
        } else {
          llAlloca = localValue->getAlloca();
        }
      } else if (irName) {
        localValue = ctx->getActiveFunction()->getBlock()->newValue(irName->value, eTy, isVar, irName->range);
        llAlloca   = localValue->getAlloca();
      } else {
        auto loc = ctx->getActiveFunction()->getBlock()->newValue(utils::unique_id(), eTy, isVar, fileRange);
        llAlloca = loc->getAlloca();
      }
    }
    if (hasOwnCount) {
      SHOW("Has own count : beginning setup")
      auto* currBlock = ctx->getActiveFunction()->getBlock();
      auto* condBlock = new IR::Block(ctx->getActiveFunction(), currBlock);
      auto* trueBlock = new IR::Block(ctx->getActiveFunction(), currBlock);
      auto* restBlock = new IR::Block(ctx->getActiveFunction(), nullptr);
      restBlock->linkPrevBlock(currBlock);
      // NOLINTNEXTLINE(readability-magic-numbers)
      auto* count = currBlock->newValue(utils::unique_id(), IR::UnsignedType::get(64u, ctx), true, fileRange);
      ctx->builder.CreateStore(llvm::ConstantInt::get(llvm::Type::getInt64Ty(ctx->llctx), 0u, false), count->getLLVM());
      (void)IR::addBranch(ctx->builder, condBlock->getBB());
      condBlock->setActive(ctx->builder);
      SHOW("Set condition block active")
      ctx->builder.CreateCondBr(
          ctx->builder.CreateICmpULT(ctx->builder.CreateLoad(count->getType()->getLLVMType(), count->getLLVM()),
                                     oCount->getLLVM()),
          trueBlock->getBB(), restBlock->getBB());
      trueBlock->setActive(ctx->builder);
      SHOW("Set trueblock active")
      Vec<llvm::Value*> valsLLVM;
      valsLLVM.push_back(ctx->builder.CreateInBoundsGEP(
          eTy->getLLVMType(), llAlloca, {ctx->builder.CreateLoad(count->getType()->getLLVMType(), count->getLLVM())}));
      for (auto* val : valsIR) {
        valsLLVM.push_back(val->getLLVM());
      }
      SHOW("Pushed all constructor arg values")
      // FIXME - Same copied values will be passed to multiple instances
      (void)cons->call(ctx, valsLLVM, ctx->getMod());
      ctx->builder.CreateStore(
          ctx->builder.CreateAdd(llvm::ConstantInt::get(count->getType()->getLLVMType(), 1u, false),
                                 ctx->builder.CreateLoad(count->getType()->getLLVMType(), count->getLLVM())),
          count->getLLVM());
      (void)IR::addBranch(ctx->builder, condBlock->getBB());
      restBlock->setActive(ctx->builder);
      auto* ptrTy = IR::PointerType::get(true, eTy, false, ownerValue, true, ctx);
      auto* resVal =
          isLocalDecl()
              ? (localValue->getType()->isMaybe()
                     ? new IR::Value(ctx->builder.CreateStructGEP(localValue->getType()->getLLVMType(),
                                                                  localValue->getLLVM(), 1u),
                                     IR::ReferenceType::get(localValue->isVariable(),
                                                            localValue->getType()->asMaybe()->getSubType(), ctx),
                                     false, IR::Nature::temporary)
                     : localValue)
              : restBlock->newValue(irName.has_value() ? irName->value : utils::unique_id(), ptrTy, isVar,
                                    irName.has_value() ? irName->range : fileRange);
      ctx->builder.CreateStore(llAlloca, ctx->builder.CreateStructGEP(ptrTy->getLLVMType(), resVal->getLLVM(), 0u));
      ctx->builder.CreateStore(oCount->getLLVM(),
                               ctx->builder.CreateStructGEP(ptrTy->getLLVMType(), resVal->getLLVM(), 1u));
      return resVal;
    } else {
      Vec<llvm::Value*> valsLLVM;
      valsLLVM.push_back(llAlloca);
      for (auto* val : valsIR) {
        valsLLVM.push_back(val->getLLVM());
      }
      (void)cons->call(ctx, valsLLVM, ctx->getMod());
    }
    if (isLocalDecl() && localValue->getType()->isMaybe()) {
      ctx->builder.CreateStore(
          llvm::ConstantInt::get(llvm::Type::getInt1Ty(ctx->llctx), 1u),
          ctx->builder.CreateStructGEP(localValue->getType()->getLLVMType(), localValue->getAlloca(), 0u));
      return localValue->toNewIRValue();
    } else {
      auto* res = new IR::Value(
          llAlloca,
          ownTy.has_value() ? (IR::QatType*)IR::PointerType::get(isVar, eTy, false, ownerValue, hasOwnCount, ctx)
                            : (IR::QatType*)eTy,
          ownTy.has_value() ? false : isVar, IR::Nature::temporary);
      if (isLocalDecl()) {
        res->setLocalID(localValue->getLocalID());
      }
      return res;
    }
  } else {
    ctx->Error("The provided type " + ctx->highlightError(typ->toString()) + " cannot have a constructor",
               type->fileRange);
  }
  return nullptr;
}

bool ConstructorCall::isOwning() const { return ownTy.has_value(); }

Json ConstructorCall::toJson() const {
  Vec<JsonValue> argsJson;
  for (auto* arg : args) {
    argsJson.push_back(arg->toJson());
  }
  return Json()
      ._("nodeType", "constructorCall")
      ._("type", type->toJson())
      ._("arguments", argsJson)
      ._("isOwn", ownTy.has_value())
      ._("ownType", ownTy.has_value() ? JsonValue(ownTyToString()) : JsonValue())
      ._("hasOwnCount", ownCount.has_value())
      ._("ownCount", ownCount.has_value() ? ownCount.value()->toJson() : JsonValue())
      ._("fileRange", fileRange);
}

} // namespace qat::ast